"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
# -------------------------------------------- #
# -------------------------------------------- #
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
# SENSIBILIDAD - VRS
resultados_in_2_vrs <- aplicar_sensibilidad(datos, lapply(resultados_in, `[[`, "data"), 0.99, "io", "vrs", FALSE)
resultados_in_3_vrs <- aplicar_sensibilidad(datos, lapply(resultados_in_2_vrs, `[[`, "data"), 0.99, "io", "vrs", FALSE)
# SENSIBILIDAD - CRS
resultados_in_2_crs <- aplicar_sensibilidad(datos, lapply(resultados_in, `[[`, "data"), 0.99, "io", "crs", FALSE)
resultados_in_3_crs <- aplicar_sensibilidad(datos, lapply(resultados_in_2_crs, `[[`, "data"), 0.99, "io", "crs", FALSE)
# Llamar a la función
lista_resultados_combinados_in <- combinar_resultados_iteraciones(resultados_in, resultados_in_2_vrs, resultados_in_3_vrs, resultados_in_2_crs, resultados_in_3_crs)
# ------------------------------------------------------------- #
# CALCULO Y VISUALIZACION DE CORRELACION DE DATOS SENSIBILIZADOS
# Revisar la correlación de los datos dentro de cada dataframe en la lista
correlaciones_lista <- lapply(lista_resultados_combinados, function(df) {
# Convertir las columnas de VRS y CRS a numéricas (en caso de que sean texto debido a "NO APLICA")
df_num <- df %>%
select(-IdEstablecimiento) %>%  # Excluir la columna IdEstablecimiento
mutate(across(starts_with("vrs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA)))) %>%
mutate(across(starts_with("crs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA))))
# Calcular la correlación solo con columnas numéricas, excluyendo NA
cor(df_num[, sapply(df_num, is.numeric)], use = "complete.obs")
})
# Llamar a la función
lista_resultados_combinados_in <- combinar_resultados_iteraciones(resultados_in, resultados_in_2_vrs, resultados_in_3_vrs, resultados_in_2_crs, resultados_in_3_crs)
# Revisar la correlación de los datos dentro de cada dataframe en la lista
correlaciones_lista <- lapply(lista_resultados_combinados_in, function(df) {
# Convertir las columnas de VRS y CRS a numéricas (en caso de que sean texto debido a "NO APLICA")
df_num <- df %>%
select(-IdEstablecimiento) %>%  # Excluir la columna IdEstablecimiento
mutate(across(starts_with("vrs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA)))) %>%
mutate(across(starts_with("crs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA))))
# Calcular la correlación solo con columnas numéricas, excluyendo NA
cor(df_num[, sapply(df_num, is.numeric)], use = "complete.obs")
})
# Nombrar la lista con los años para identificación
names(correlaciones_lista) <- names(lista_resultados_combinados)
# Nombrar la lista con los años para identificación
names(correlaciones_lista) <- names(lista_resultados_combinados_in)
# Mostrar las correlaciones
correlaciones_lista
# Instalar y cargar la librería corrplot si no está instalada
if (!require(corrplot)) install.packages("corrplot")
library(corrplot)
# Definir la cuadrícula de gráficos (por ejemplo, 2 filas x 3 columnas)
num_graficos <- length(correlaciones_lista)
filas <- ceiling(sqrt(num_graficos))
columnas <- ceiling(num_graficos / filas)
# Ajustar la ventana gráfica
par(mfrow = c(filas, columnas), mar = c(1, 1, 2, 1))  # Ajusta los márgenes y la cuadrícula
# Graficar todas las matrices de correlación
for (anio in names(correlaciones_lista)) {
corrplot(correlaciones_lista[[anio]], method = "color", title = paste("Matriz de Correlación - Año", anio))
}
# Restablecer la configuración gráfica por defecto
par(mfrow = c(1, 1))
library(reshape2)
library(ggplot2)
# Crear una lista para almacenar las correlaciones entre matrices de distintos años
correlacion_entre_anios <- list()
# Calcular la correlación entre las matrices de correlación de cada par de años consecutivos
for (i in 1:(length(anios) - 1)) {
anio_actual <- anios[i]
anio_siguiente <- anios[i + 1]
# Tomar las matrices de correlación y convertirlas a vectores para comparación
matriz_actual <- as.vector(correlaciones_lista[[anio_actual]])
matriz_siguiente <- as.vector(correlaciones_lista[[anio_siguiente]])
# Calcular la correlación entre las dos matrices (vectores)
correlacion <- cor(matriz_actual, matriz_siguiente, use = "complete.obs")
correlacion_entre_anios[[paste(anio_actual, "vs", anio_siguiente)]] <- correlacion
}
# Mostrar la correlación entre los años
correlacion_entre_anios
# Graficar la correlación entre los años como un gráfico de barras
correlacion_df <- data.frame(
Comparacion = names(correlacion_entre_anios),
Correlacion = unlist(correlacion_entre_anios)
)
ggplot(correlacion_df, aes(x = Comparacion, y = Correlacion, fill = Correlacion)) +
geom_bar(stat = "identity") +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
labs(title = "Correlación entre matrices de correlación de distintos años", x = "Comparación de Años", y = "Correlación") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Graficar la correlación entre los años como un gráfico de barras
correlacion_df <- data.frame(
Comparacion = names(correlacion_entre_anios),
Correlacion = unlist(correlacion_entre_anios)
)
ggplot(correlacion_df, aes(x = Comparacion, y = Correlacion, fill = Correlacion)) +
geom_bar(stat = "identity") +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
labs(title = "Correlación entre matrices de correlación de distintos años", x = "Comparación de Años", y = "Correlación") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
install.packages("Benchmarking")
source("functions.R")
dea_malquist <- function(datos)
dea_malquist <- function(datos)
datas <- datos
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[[1]]$data))
datas <- datos
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[[1]]$data))
techch_accumulated <- rep(1, nrow(datas[[1]]$data))
malmquist_accumulated <- rep(1, nrow(datas[[1]]$data))
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[["2014"]]$data))
datas[["2014"]]
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[["2014"]]))
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[["2014"]]))
techch_accumulated <- rep(1, nrow(datas[["2014"]]))
malmquist_accumulated <- rep(1, nrow(datas[["2014"]]))
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]$data
data_period2 <- datas[[i + 1]]$data
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Crear un data frame con los resultados acumulados
results <- data.frame(DMU = 1:nrow(datas[[1]]$data),
Effch_Accumulated = effch_accumulated,
Techch_Accumulated = techch_accumulated,
Malmquist_Accumulated = malmquist_accumulated)
# Crear un data frame con los resultados acumulados
results <- data.frame(DMU = 1:nrow(datas[["2014"]]),
Effch_Accumulated = effch_accumulated,
Techch_Accumulated = techch_accumulated,
Malmquist_Accumulated = malmquist_accumulated)
# Mostrar los resultados
print(results)
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[[1]]))
# Inicializar vectores acumulados para cada componente
effch_accumulated <- rep(1, nrow(datas[[1]]))
techch_accumulated <- rep(1, nrow(datas[[1]]))
malmquist_accumulated <- rep(1, nrow(datas[[1]]))
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, RTS = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
dea_malmquist <- function(datas) {
datas <- datos
effch_accumulated <- rep(1, nrow(datas[[1]]))
techch_accumulated <- rep(1, nrow(datas[[1]]))
malmquist_accumulated <- rep(1, nrow(datas[[1]]))
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Crear un data frame con los resultados acumulados
results <- data.frame(DMU = 1:nrow(datas[[1]]),
Effch_Accumulated = effch_accumulated,
Techch_Accumulated = techch_accumulated,
Malmquist_Accumulated = malmquist_accumulated)
# Mostrar los resultados
print(results)
return(results)
}
datas <- datos
effch_accumulated <- rep(1, nrow(datas[[1]]))
techch_accumulated <- rep(1, nrow(datas[[1]]))
malmquist_accumulated <- rep(1, nrow(datas[[1]]))
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
for (i in 1:(length(datas) - 1)) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Recorrer la lista para calcular el índice de Malmquist entre periodos consecutivos
#for (i in 1:(length(datas) - 1)) {
for (i in 1:2) {
# Extraer los datos de cada periodo
data_period1 <- datas[[i]]
data_period2 <- datas[[i + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
# Acumular los índices multiplicando los resultados de cada par de periodos
effch_accumulated <- effch_accumulated * malmquist_result$EFFCH
techch_accumulated <- techch_accumulated * malmquist_result$TECHCH
malmquist_accumulated <- malmquist_accumulated * malmquist_result$MALMQUIST
}
# Crear un data frame con los resultados acumulados
results <- data.frame(DMU = 1:nrow(datas[[1]]),
Effch_Accumulated = effch_accumulated,
Techch_Accumulated = techch_accumulated,
Malmquist_Accumulated = malmquist_accumulated)
# Mostrar los resultados
print(results)
# Extraer los datos de cada periodo
data_period1 <- datas[[1]]
data_period2 <- datas[[1 + 1]]
# Seleccionar las columnas 8:10 como inputs y 5:7 como outputs, y convertir a matrices
inputs_period1 <- as.matrix(data_period1[, 8:10])
outputs_period1 <- as.matrix(data_period1[, 5:7])
inputs_period2 <- as.matrix(data_period2[, 8:10])
outputs_period2 <- as.matrix(data_period2[, 5:7])
# Calcular el índice de Malmquist para el par de periodos actual
malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
eff_period1 <- dea(inputs_period1, outputs_period1, RTS = "vrs")
eff_period2 <- dea(inputs_period2, outputs_period2, RTS = "vrs")
# Calcular el índice de Malmquist para el par de periodos actual
#malmquist_result <- malmquist(inputs_period1, outputs_period1, inputs_period2, outputs_period2, rts = "vrs")
malmquist_result <- malmquist(eff_period1, eff_period2)
inputs <- rbind(inputs_period1, inputs_period2)
outputs <- rbind(outputs_period1, outputs_period2)
time <- c(rep(1, nrow(inputs_period1)), rep(2, nrow(inputs_period2)))
# Crear un dataframe completo
data <- data.frame(TIME = time, inputs, outputs)
# Ejecutar el análisis de Malmquist con la variable de tiempo
malmquist_result <- malmquist(data, rts = "vrs", TIME = "TIME")
# Ejecutar el análisis de Malmquist con la variable de tiempo
malmquist_result <- malmquist(data, RTS = "vrs", TIME = "TIME")
View(data)
View(data_period1)
library(corrplot)
library(gridExtra)
library(purrr)
install.packages("Benchmarking")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ----------------------------------------------- #
# Periodo previo a pandemia #
# Datos #
datos <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
library(corrplot)
library(gridExtra)
library(purrr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ----------------------------------------------- #
# Periodo previo a pandemia #
# Datos #
datos <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
# CALCULO Y VISUALIZACION DE CORRELACION DE DATOS SENSIBILIZADOS
# Revisar la correlación de los datos dentro de cada dataframe en la lista
correlaciones_lista <- lapply(lista_resultados_combinados_in, function(df) {
# Convertir las columnas de VRS y CRS a numéricas (en caso de que sean texto debido a "NO APLICA")
df_num <- df %>%
select(-IdEstablecimiento) %>%  # Excluir la columna IdEstablecimiento
mutate(across(starts_with("vrs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA)))) %>%
mutate(across(starts_with("crs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA))))
# Calcular la correlación solo con columnas numéricas, excluyendo NA
cor(df_num[, sapply(df_num, is.numeric)], use = "complete.obs")
})
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
# Llamar a la función
lista_resultados_combinados_in <- combinar_resultados_iteraciones(resultados_in, resultados_in_2_vrs, resultados_in_3_vrs, resultados_in_2_crs, resultados_in_3_crs)
# Revisar la correlación de los datos dentro de cada dataframe en la lista
correlaciones_lista <- lapply(lista_resultados_combinados_in, function(df) {
# Convertir las columnas de VRS y CRS a numéricas (en caso de que sean texto debido a "NO APLICA")
df_num <- df %>%
select(-IdEstablecimiento) %>%  # Excluir la columna IdEstablecimiento
mutate(across(starts_with("vrs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA)))) %>%
mutate(across(starts_with("crs_iteracion_"), ~ as.numeric(replace(., . == "NO APLICA", NA))))
# Calcular la correlación solo con columnas numéricas, excluyendo NA
cor(df_num[, sapply(df_num, is.numeric)], use = "complete.obs")
})
# Llamar a la función
lista_resultados_combinados_in <- combinar_resultados_iteraciones(resultados_in, resultados_in_2_vrs, resultados_in_3_vrs, resultados_in_2_crs, resultados_in_3_crs)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
resultados_in_3_vrs <- aplicar_sensibilidad(datos, lapply(resultados_in_2_vrs, `[[`, "data"), 0.99, "io", "vrs", FALSE)
# SENSIBILIDAD - VRS
resultados_in_2_vrs <- aplicar_sensibilidad(datos, lapply(resultados_in, `[[`, "data"), 0.99, "io", "vrs", FALSE)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
datos <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
data<- datos[["2014"]]
orientation <- "io"
# Preparar inputs y outputs
model <- make_deadata(data, ni=3, no=3, dmus=3, inputs=8:10, outputs=5:7)
# Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
# Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
eficiencia_crs <- efficiencies(resultado_dea_crs)
# Crear dataframe con eficiencias y retorno a escala
eficiencia_df <- data.frame(
IdEstablecimiento = data$IdEstablecimiento,
Nombre = data$'Nombre Establecimiento',
Region = data$'Region',
vrs = round(eficiencia_vrs, 3),
crs = round(eficiencia_crs, 3),
escala = round(eficiencia_vrs / eficiencia_crs, 3),
latitud = data$latitud,
longitud = data$longitud,
region_id = data$region_id
)
data<- datos[["2014"]]
View(data)
View(data)
# Preparar inputs y outputs
model <- make_deadata(data, ni=3, no=3, dmus=3, inputs=8:10, outputs=5:7)
View(model)
# Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
View(resultado_dea_vrs)
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
# Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
library(corrplot)
library(gridExtra)
library(purrr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ----------------------------------------------- #
# Periodo previo a pandemia #
# Datos #
datos <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
data<- datos[["2014"]]
orientation <- "io"
# Preparar inputs y outputs
model <- make_deadata(data, ni=3, no=3, dmus=3, inputs=8:10, outputs=5:7)
# Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
# Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
eficiencia_crs <- efficiencies(resultado_dea_crs)
# Crear dataframe con eficiencias y retorno a escala
eficiencia_df <- data.frame(
IdEstablecimiento = data$IdEstablecimiento,
Nombre = data$'Nombre Establecimiento',
Region = data$'Region',
vrs = round(eficiencia_vrs, 3),
crs = round(eficiencia_crs, 3),
escala = round(eficiencia_vrs / eficiencia_crs, 3),
latitud = data$latitud,
longitud = data$longitud,
region_id = data$region_id
)
View(resultado_dea_crs)
View(resultado_dea_vrs)
resultado_dea_vrs[["weight_slack_i"]]
resultado_dea_vrs[["weight_slack_o"]]
library(deaR)
# Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
# Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
eficiencia_crs <- efficiencies(resultado_dea_crs)
library(corrplot)
library(gridExtra)
library(purrr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ----------------------------------------------- #
# Periodo previo a pandemia #
# Datos #
datos <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019)
)
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
# Preparar inputs y outputs
model <- make_deadata(data, ni=3, no="IdEstablecimiento", dmus=3, inputs=8:10, outputs=5:7)
data<- datos[["2014"]]
orientation <- "io"
# Preparar inputs y outputs
model <- make_deadata(data, ni=3, no="IdEstablecimiento", dmus=3, inputs=8:10, outputs=5:7)
# Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
# Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
