library(readxl)
library(readxl)
library(openxlsx)
library(dplyr)
library(deaR)
install.packages("readxl")
library(dplyr)
load("~/Escritorio/MEMORIA/Memoria/RESULTADOS_COMBINADOS_in_vrs.RData")
View(resultados_combinados)
resultado_in <- resultados_combinados
load("~/Escritorio/MEMORIA/Memoria/RESULTADOS_COMBINADOS.RData")
View(resultados_combinados)
View(resultado_in)
View(resultados_combinados)
load("~/Escritorio/MEMORIA/Memoria/RESULTADOS_COMBINADOS_OUT.RData")
View(resultados_combinados)
View(resultados_combinados)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ==============================================
#  PRE PROCESAMIENTO DE DATOS
# ==============================================
#  CONSOLIDADO DE DATOS POR AÑO
anios <- 2014:2023
anios_pre_pandemia <- c("2014", "2015", "2016", "2017", "2018", "2019")
anios_pandemia <- c("2020", "2021", "2022", "2023")
datos_iniciales <- lapply(anios, consolidar_datos_por_anio)
names(datos_iniciales) <- as.character(anios)
View(datos_iniciales)
datos_iniciales[["2014"]][["complejidad"]]
# Encontrar las DMUs comunes en todos los años y filtrar los datos para incluir solo esas DMUs
dmus_comunes <- Reduce(intersect, lapply(datos_iniciales, `[[`, "IdEstablecimiento"))
datos <- lapply(datos_iniciales, function(data) data[data$IdEstablecimiento %in% dmus_comunes, ])
load("~/Escritorio/MEMORIA/Memoria/Resultados.RData")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
orientacion <- "oo"
retorno <- "vrs"
columna <- "vrs_oo"
resultados_usar <- resultados_sin_atipicos[[columna]]
# Vector de años de interés
years <- 2014:2023
View(resultados_usar)
path_hospitales_complejidades <- paste0("data/hospitales.csv")
hospitales_complejidades <- read.csv(path_hospitales_complejidades) %>% rename("IdEstablecimiento" = "hospital_id")
for (year in 2014:2023) {
resultados_usar$original[[as.character(year)]]$data <- resultados_usar$original[[as.character(year)]]$data %>%
left_join(hospitales_complejidades %>% select(IdEstablecimiento, complejidad),
by = "IdEstablecimiento")
}
View(hospitales_complejidades)
for (year in 2014:2023) {
resultados_usar[[orientacion]]$original[[as.character(year)]]$data <- resultados_usar[[orientacion]]$original[[as.character(year)]]$data %>%
left_join(hospitales_complejidades %>% select(IdEstablecimiento, complejidad),
by = "IdEstablecimiento")
}
View(resultados_usar)
datos_usar <- datos_sin_atipicos[[columna]]
# DATOS SIN ATIPICOS PARA VRS OO
malmquist_indices <- malmquist(datos_usar,retorno, "out")
generar_graficas_malmquist(malmquist_indices$index,"out_vrs")
# Aplicar Random Forest para cada año
random_forest <- lapply(anios, function(anio) {analize_rf(anio, resultados_in = resultados_usar[[orientacion]], 500, retorno, "Entradas")})
# Asignar nombres a la lista de modelos
names(random_forest) <- paste0(anios)
# Llamar a la función
resultados_importancia <- importancia_dataframe(random_forest)
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
df_incmse_est <- resultados_importancia[["df_incmse_est_10"]]
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
guardar_dataframe_por_columna <- function(dataframes, columna) {
# Validar que la columna sea un único valor
if (!is.character(columna) || length(columna) != 1) {
stop("El parámetro 'columna' debe ser un único nombre de columna.")
}
# Extraer datos para la columna especificada
resultados <- lapply(names(dataframes[["original"]]), function(anio) {
message(paste("Procesando el año:", anio))
df <- dataframes[["original"]][[anio]][["data"]]
if (is.null(df)) {
warning(paste("Datos nulos para el año", anio))
return(NULL)
}
if (!all(c("IdEstablecimiento", "Nombre","complejidad") %in% colnames(df))) {
warning(paste("El año", anio, "no contiene 'IdEstablecimiento', 'Nombre' o 'complejidad'"))
return(NULL)
}
if (!(columna %in% colnames(df))) {
warning(paste("El año", anio, "no contiene la columna", columna))
return(NULL)
}
message(paste("Datos válidos encontrados para el año", anio))
df_seleccionado <- reemplazar_nulos(df[, c("IdEstablecimiento", "Nombre", "complejidad", columna)])
colnames(df_seleccionado) <- c("IdEstablecimiento", "Nombre", anio)  # Renombrar columna con el año
return(df_seleccionado)
})
# Filtrar resultados no nulos
resultados <- Filter(Negate(is.null), resultados)
if (length(resultados) == 0) {
warning("No hay datos válidos para los años procesados")
return(NULL)
}
# Combinar resultados en un solo dataframe asegurando mantener "Nombre"
df_final <- Reduce(function(x, y) merge(x, y, by = c("IdEstablecimiento", "Nombre","complejidad"), all = TRUE), resultados)
# Unificar filas por IdEstablecimiento
df_final <- df_final %>%
group_by(IdEstablecimiento) %>%
summarise(
Nombre = first(Nombre),  # Toma el primer nombre disponible
across(where(is.numeric), ~ mean(.x, na.rm = TRUE))  # Promedio de valores numéricos
) %>%
ungroup()
return(df_final)
}
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
guardar_dataframe_por_columna <- function(dataframes, columna) {
# Validar que la columna sea un único valor
if (!is.character(columna) || length(columna) != 1) {
stop("El parámetro 'columna' debe ser un único nombre de columna.")
}
# Extraer datos para la columna especificada
resultados <- lapply(names(dataframes[["original"]]), function(anio) {
message(paste("Procesando el año:", anio))
df <- dataframes[["original"]][[anio]][["data"]]
if (is.null(df)) {
warning(paste("Datos nulos para el año", anio))
return(NULL)
}
if (!all(c("IdEstablecimiento", "Nombre","complejidad") %in% colnames(df))) {
warning(paste("El año", anio, "no contiene 'IdEstablecimiento', 'Nombre' o 'complejidad'"))
return(NULL)
}
if (!(columna %in% colnames(df))) {
warning(paste("El año", anio, "no contiene la columna", columna))
return(NULL)
}
message(paste("Datos válidos encontrados para el año", anio))
df_seleccionado <- reemplazar_nulos(df[, c("IdEstablecimiento", "Nombre", "complejidad", columna)])
colnames(df_seleccionado) <- c("IdEstablecimiento", "Nombre","complejidad", anio)  # Renombrar columna con el año
return(df_seleccionado)
})
# Filtrar resultados no nulos
resultados <- Filter(Negate(is.null), resultados)
if (length(resultados) == 0) {
warning("No hay datos válidos para los años procesados")
return(NULL)
}
# Combinar resultados en un solo dataframe asegurando mantener "Nombre"
df_final <- Reduce(function(x, y) merge(x, y, by = c("IdEstablecimiento", "Nombre","complejidad"), all = TRUE), resultados)
# Unificar filas por IdEstablecimiento
df_final <- df_final %>%
group_by(IdEstablecimiento) %>%
summarise(
Nombre = first(Nombre),  # Toma el primer nombre disponible
Complejidad = first(Complejidad),
across(where(is.numeric), ~ mean(.x, na.rm = TRUE))  # Promedio de valores numéricos
) %>%
ungroup()
return(df_final)
}
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
View(resultados_usar)
test <- guardar_dataframe_por_columna(resultados_usar[[orientacion]],retorno)
guardar_dataframe_por_columna <- function(dataframes, columna) {
# Validar que la columna sea un único valor
if (!is.character(columna) || length(columna) != 1) {
stop("El parámetro 'columna' debe ser un único nombre de columna.")
}
# Extraer datos para la columna especificada
resultados <- lapply(names(dataframes[["original"]]), function(anio) {
message(paste("Procesando el año:", anio))
df <- dataframes[["original"]][[anio]][["data"]]
if (is.null(df)) {
warning(paste("Datos nulos para el año", anio))
return(NULL)
}
if (!all(c("IdEstablecimiento", "Nombre","complejidad") %in% colnames(df))) {
warning(paste("El año", anio, "no contiene 'IdEstablecimiento', 'Nombre' o 'complejidad'"))
return(NULL)
}
if (!(columna %in% colnames(df))) {
warning(paste("El año", anio, "no contiene la columna", columna))
return(NULL)
}
message(paste("Datos válidos encontrados para el año", anio))
df_seleccionado <- reemplazar_nulos(df[, c("IdEstablecimiento", "Nombre", "complejidad", columna)])
colnames(df_seleccionado) <- c("IdEstablecimiento", "Nombre","complejidad", anio)  # Renombrar columna con el año
return(df_seleccionado)
})
# Filtrar resultados no nulos
resultados <- Filter(Negate(is.null), resultados)
if (length(resultados) == 0) {
warning("No hay datos válidos para los años procesados")
return(NULL)
}
# Combinar resultados en un solo dataframe asegurando mantener "Nombre"
df_final <- Reduce(function(x, y) merge(x, y, by = c("IdEstablecimiento", "Nombre","complejidad"), all = TRUE), resultados)
# Unificar filas por IdEstablecimiento
df_final <- df_final %>%
group_by(IdEstablecimiento) %>%
summarise(
Nombre = first(Nombre),  # Toma el primer nombre disponible
complejidad = first(complejidad),
across(where(is.numeric), ~ mean(.x, na.rm = TRUE))  # Promedio de valores numéricos
) %>%
ungroup()
return(df_final)
}
test <- guardar_dataframe_por_columna(resultados_usar[[orientacion]],retorno)
View(test)
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
View(test)
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
guardar_dataframe_por_columna <- function(dataframes, columna) {
# Validar que la columna sea un único valor
if (!is.character(columna) || length(columna) != 1) {
stop("El parámetro 'columna' debe ser un único nombre de columna.")
}
# Extraer datos para la columna especificada
resultados <- lapply(names(dataframes[["original"]]), function(anio) {
message(paste("Procesando el año:", anio))
df <- dataframes[["original"]][[anio]][["data"]]
if (is.null(df)) {
warning(paste("Datos nulos para el año", anio))
return(NULL)
}
if (!all(c("IdEstablecimiento", "Nombre","complejidad") %in% colnames(df))) {
warning(paste("El año", anio, "no contiene 'IdEstablecimiento', 'Nombre' o 'complejidad'"))
return(NULL)
}
if (!(columna %in% colnames(df))) {
warning(paste("El año", anio, "no contiene la columna", columna))
return(NULL)
}
message(paste("Datos válidos encontrados para el año", anio))
df_seleccionado <- reemplazar_nulos(df[, c("IdEstablecimiento", "Nombre", "complejidad", columna)])
colnames(df_seleccionado) <- c("IdEstablecimiento", "Nombre","complejidad", anio)  # Renombrar columna con el año
return(df_seleccionado)
})
# Filtrar resultados no nulos
resultados <- Filter(Negate(is.null), resultados)
if (length(resultados) == 0) {
warning("No hay datos válidos para los años procesados")
return(NULL)
}
# Combinar resultados en un solo dataframe asegurando mantener "Nombre"
df_final <- Reduce(function(x, y) merge(x, y, by = c("IdEstablecimiento", "Nombre","complejidad"), all = TRUE), resultados)
# Unificar filas por IdEstablecimiento
df_final <- df_final %>%
group_by(IdEstablecimiento) %>%
summarise(
Nombre = first(Nombre),  # Toma el primer nombre disponible
complejidad = first(complejidad),
across(where(is.numeric), ~ mean(.x, na.rm = TRUE))  # Promedio de valores numéricos
) %>%
ungroup()
return(df_final)
}
# ==============================================
#  GUARDAR DATOS DE EFICIENCIA Y DETERMINANTES
# ==============================================
guardar_resultados <- function(dataframes, retorno, resultados_importancia,
malmquist,
carpeta,
archivo_salida, prefijo) {
ruta_completa <- file.path(carpeta, archivo_salida)
# Verificar si la carpeta existe, si no, crearla
if (!dir.exists(carpeta)) {
dir.create(carpeta, recursive = TRUE)  # recursive = TRUE permite crear subcarpetas si es necesario
}
reemplazar_nulos <- function(df) {
df <- df %>% mutate(across(everything(), ~ ifelse(is.na(.x) | .x == "", "-", .x)))
return(df)
}
# Crear un workbook
wb <- createWorkbook()
# EFICIENCIA TÉCNICA
ef_tec <- guardar_dataframe_por_columna(dataframes, retorno)
addWorksheet(wb, "ET")
writeData(wb, "ET", ef_tec)
# MALMQUIST
addWorksheet(wb, "MALMQUIST")
writeData(wb, "MALMQUIST", malmquist)
#df_pre <- as.data.frame(resultados_importancia[["DataFrame_Pre"]])
#df_post <- as.data.frame(resultados_importancia[["DataFrame_Post"]])
#df_general <- as.data.frame(resultados_importancia[["DataFrame_General"]])
# Escribir en el Excel solo si no están vacíos
if (nrow(resultados_importancia) > 0) {
addWorksheet(wb, "DETERM")
writeData(wb, "DETERM", resultados_importancia)
}
# Convertir listas a DataFrames si es necesario
#df_pre <- as.data.frame(resultados_importancia[["DataFrame_Pre"]])
#df_post <- as.data.frame(resultados_importancia[["DataFrame_Post"]])
#df_general <- as.data.frame(resultados_importancia[["DataFrame_General"]])
# Escribir en el Excel solo si no están vacíos
#if (nrow(df_pre) > 0) {
#  addWorksheet(wb, "DET PRE")
#  writeData(wb, "DET PRE", df_pre)
#}
#if (nrow(df_post) > 0) {
#  addWorksheet(wb, "DET POST")
#  writeData(wb, "DET POST", df_post)
#}
#if (nrow(df_general) > 0) {
#  addWorksheet(wb, "DET GENERAL")
#  writeData(wb, "DET GENERAL", df_general)
#}
# Guardar el archivo
saveWorkbook(wb, archivo_salida, overwrite = TRUE)
cat("Archivo guardado como:", archivo_salida, "\n")
}
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
df_incmse_est <- resultados_importancia[["df_incmse_est_10"]]
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
# ==============================================
#  GUARDAR DATOS DE EFICIENCIA Y DETERMINANTES
# ==============================================
guardar_resultados <- function(dataframes, retorno, resultados_importancia,
malmquist,
carpeta,
archivo_salida, prefijo) {
ruta_completa <- file.path(carpeta, archivo_salida)
# Verificar si la carpeta existe, si no, crearla
if (!dir.exists(carpeta)) {
dir.create(carpeta, recursive = TRUE)  # recursive = TRUE permite crear subcarpetas si es necesario
}
reemplazar_nulos <- function(df) {
df <- df %>% mutate(across(everything(), ~ ifelse(is.na(.x) | .x == "", "-", .x)))
return(df)
}
# Crear un workbook
wb <- createWorkbook()
# EFICIENCIA TÉCNICA
browser()
ef_tec <- guardar_dataframe_por_columna(dataframes, retorno)
addWorksheet(wb, "ET")
writeData(wb, "ET", ef_tec)
# MALMQUIST
addWorksheet(wb, "MALMQUIST")
writeData(wb, "MALMQUIST", malmquist)
#df_pre <- as.data.frame(resultados_importancia[["DataFrame_Pre"]])
#df_post <- as.data.frame(resultados_importancia[["DataFrame_Post"]])
#df_general <- as.data.frame(resultados_importancia[["DataFrame_General"]])
# Escribir en el Excel solo si no están vacíos
if (nrow(resultados_importancia) > 0) {
addWorksheet(wb, "DETERM")
writeData(wb, "DETERM", resultados_importancia)
}
# Convertir listas a DataFrames si es necesario
#df_pre <- as.data.frame(resultados_importancia[["DataFrame_Pre"]])
#df_post <- as.data.frame(resultados_importancia[["DataFrame_Post"]])
#df_general <- as.data.frame(resultados_importancia[["DataFrame_General"]])
# Escribir en el Excel solo si no están vacíos
#if (nrow(df_pre) > 0) {
#  addWorksheet(wb, "DET PRE")
#  writeData(wb, "DET PRE", df_pre)
#}
#if (nrow(df_post) > 0) {
#  addWorksheet(wb, "DET POST")
#  writeData(wb, "DET POST", df_post)
#}
#if (nrow(df_general) > 0) {
#  addWorksheet(wb, "DET GENERAL")
#  writeData(wb, "DET GENERAL", df_general)
#}
# Guardar el archivo
saveWorkbook(wb, archivo_salida, overwrite = TRUE)
cat("Archivo guardado como:", archivo_salida, "\n")
}
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
ef_tec
source("auxiliar.R")
# Almacenar resultados en excel
guardar_resultados(
dataframes = resultados_usar[[orientacion]],
retorno,
df_incmse_est,
malmquist = malmquist_indices$index,
carpeta="results/oo_vrs",
archivo_salida = "RESULTADOS.xlsx",
prefijo = orientacion
)
# ALTA COMPLEJIDAD
ef_tec_alta <- guardar_dataframe_por_columna(resultados_usar[["oo"]], retorno)
# ALTA COMPLEJIDAD
ef_tec_alta <- guardar_dataframe_por_columna(resultados_usar[["oo"]], retorno)
save.image("~/Escritorio/MEMORIA/Memoria/RESPALDO_17.RData")
load("~/Escritorio/MEMORIA/Memoria/RESPALDO_17.RData")
