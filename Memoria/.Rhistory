library(corrplot)
library(gridExtra)
library(purrr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("functions.R")
source("graphics.R")
# ----------------------------------------------- #
# Periodo previo a pandemia #
anios <- c("2014", "2015", "2016", "2017", "2018", "2019","2020")
# Datos #
datos_iniciales <- list(
"2014" = consolidar_datos_por_anio(2014),
"2015" = consolidar_datos_por_anio(2015),
"2016" = consolidar_datos_por_anio(2016),
"2017" = consolidar_datos_por_anio(2017),
"2018" = consolidar_datos_por_anio(2018),
"2019" = consolidar_datos_por_anio(2019),
"2020" = consolidar_datos_por_anio(2020)
)
# Extraer los conjuntos de DMUs de cada año
dmus_por_anio <- lapply(datos_iniciales, function(data) data$IdEstablecimiento)
# Encontrar las DMUs comunes en todos los años
dmus_comunes <- Reduce(intersect, dmus_por_anio)
# Filtrar los datos de cada año para incluir solo las DMUs comunes
datos <- lapply(datos_iniciales, function(data) data[data$IdEstablecimiento %in% dmus_comunes, ])
# -------------------------------------------- #
# -------------------------------------------- #
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
analisis_dea_general <- function(data, orientation) {
# --- Preparar inputs y outputs
model <- make_deadata(data, ni=3, no="IdEstablecimiento", dmus=3, inputs=8:10, outputs=5:7)
# ---Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
#--- Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
eficiencia_crs <- efficiencies(resultado_dea_crs)
#inputs <- as.matrix(data[, 8:10])  # Columnas de entradas
#outputs <- as.matrix(data[, 5:7])  # Columnas de salidas
# Aplicar DEA con orientación y RTS
# Cambia `orientation` por "in" (input-oriented) o "out" (output-oriented) según sea necesario
# DEA VRS (Retornos Variables a Escala)
#resultado_dea_vrs <- dea(X = inputs, Y = outputs, RTS = "vrs", ORIENTATION = "out")
# DEA CRS (Retornos Constantes a Escala)
#resultado_dea_crs <- dea(X = inputs, Y = outputs, RTS = "crs", ORIENTATION = "out")
# Calcular eficiencias
# Las eficiencias están directamente en el objeto resultado_dea_vrs y resultado_dea_crs
#eficiencia_vrs <- efficiencies(resultado_dea_vrs)
#eficiencia_crs <- efficiencies(resultado_dea_crs)
# Crear dataframe con eficiencias y retorno a escala
eficiencia_df <- data.frame(
IdEstablecimiento = data$IdEstablecimiento,
Nombre = data$'Nombre Establecimiento',
Region = data$'Region',
vrs = round(eficiencia_vrs, 3),
crs = round(eficiencia_crs, 3),
escala = round(eficiencia_vrs / eficiencia_crs, 3),
latitud = data$latitud,
longitud = data$longitud,
region_id = data$region_id
)
# Ordenar dataframes según diferentes columnas
#eficiencia_vrs_data <- eficiencia_df[order(-eficiencia_df$vrs), ]
#eficiencia_crs_data <- eficiencia_df[order(-eficiencia_df$crs), ]
#eficiencia_escala_data <- eficiencia_df[order(eficiencia_df$escala), ]
# Retornar los dataframes ordenados como una lista
#return(list(data = eficiencia_df,
#            dea_vrs = resultado_dea_vrs,
#            dea_crs = resultado_dea_crs,
#            inputs= inputs,
#            outputs= outputs))
return(list(data = eficiencia_df))
#            vrs = eficiencia_vrs_data,
#            crs = eficiencia_crs_data,
#            esc = eficiencia_escala_data))
}
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
View(resultados_in)
analisis_dea_general <- function(data, orientation) {
# --- Preparar inputs y outputs
model <- make_deadata(data, ni=3, no="IdEstablecimiento", dmus=3, inputs=8:10, outputs=5:7)
# ---Aplicar DEA con la orientación y RTS (VRS y CRS)
resultado_dea_vrs <- model_basic(model, orientation=orientation, rts="vrs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
resultado_dea_crs <- model_basic(model, orientation=orientation, rts="crs", dmu_eval = 1:nrow(data), dmu_ref = 1:nrow(data))
#--- Calcular eficiencias
eficiencia_vrs <- efficiencies(resultado_dea_vrs)
eficiencia_crs <- efficiencies(resultado_dea_crs)
#inputs <- as.matrix(data[, 8:10])  # Columnas de entradas
#outputs <- as.matrix(data[, 5:7])  # Columnas de salidas
# Aplicar DEA con orientación y RTS
# Cambia `orientation` por "in" (input-oriented) o "out" (output-oriented) según sea necesario
# DEA VRS (Retornos Variables a Escala)
#resultado_dea_vrs <- dea(X = inputs, Y = outputs, RTS = "vrs", ORIENTATION = "out")
# DEA CRS (Retornos Constantes a Escala)
#resultado_dea_crs <- dea(X = inputs, Y = outputs, RTS = "crs", ORIENTATION = "out")
# Calcular eficiencias
# Las eficiencias están directamente en el objeto resultado_dea_vrs y resultado_dea_crs
#eficiencia_vrs <- efficiencies(resultado_dea_vrs)
#eficiencia_crs <- efficiencies(resultado_dea_crs)
# Crear dataframe con eficiencias y retorno a escala
eficiencia_df <- data.frame(
IdEstablecimiento = data$IdEstablecimiento,
Nombre = data$'Nombre Establecimiento',
Region = data$'Region',
vrs = round(eficiencia_vrs, 3),
crs = round(eficiencia_crs, 3),
escala = round(eficiencia_vrs / eficiencia_crs, 3),
latitud = data$latitud,
longitud = data$longitud,
region_id = data$region_id
)
# Ordenar dataframes según diferentes columnas
#eficiencia_vrs_data <- eficiencia_df[order(-eficiencia_df$vrs), ]
#eficiencia_crs_data <- eficiencia_df[order(-eficiencia_df$crs), ]
#eficiencia_escala_data <- eficiencia_df[order(eficiencia_df$escala), ]
# Retornar los dataframes ordenados como una lista
return(list(data = eficiencia_df,
dea_vrs = resultado_dea_vrs,
dea_crs = resultado_dea_crs))
#return(list(data = eficiencia_df))
#            vrs = eficiencia_vrs_data,
#            crs = eficiencia_crs_data,
#            esc = eficiencia_escala_data))
}
# DEA - INPUT
resultados_in <- aplicar_analisis_dea(datos, "io")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
ID <- datos[["2014"]]$IdEstablecimiento
View(datos)
datos[["2014"]][["Egresos.GRD"]]
datos[["2015"]][["Egresos.GRD"]]
library(Benchmarking)
# Iterar sobre cada año
for (year in names(datos)) {
# Acceder a la lista 'data' dentro de cada año
data_year <- datos[[year]]
# Extraer los inputs y outputs usando posiciones de columnas
inputs <- as.matrix(data_year[, 8:10])  # Columnas 8 a 10 como inputs
outputs <- as.matrix(data_year[, 5:7])  # Columnas 5 a 7 como outputs
# Agregar los datos de este año a las listas
input_data[[year]] <- inputs
output_data[[year]] <- outputs
# Crear vectores de ID y tiempo
ID <- c(ID, data_year$IdEstablecimiento)  # Suponiendo que IdEstablecimiento es el ID de cada DMU
TIME <- c(TIME, rep(year, nrow(data_year)))
}
# Inicializar listas y vectores para almacenar inputs, outputs, ID y TIME
input_data <- list()
output_data <- list()
ID <- vector()
TIME <- vector()
# Iterar sobre cada año
for (year in names(datos)) {
# Acceder a la lista 'data' dentro de cada año
data_year <- datos[[year]]
# Extraer los inputs y outputs usando posiciones de columnas
inputs <- as.matrix(data_year[, 8:10])  # Columnas 8 a 10 como inputs
outputs <- as.matrix(data_year[, 5:7])  # Columnas 5 a 7 como outputs
# Agregar los datos de este año a las listas
input_data[[year]] <- inputs
output_data[[year]] <- outputs
# Crear vectores de ID y tiempo
ID <- c(ID, data_year$IdEstablecimiento)  # Suponiendo que IdEstablecimiento es el ID de cada DMU
TIME <- c(TIME, rep(year, nrow(data_year)))
}
# Verificar si hay combinaciones duplicadas de ID y TIME
temp_df <- data.frame(ID = ID, TIME = TIME)
duplicated_rows <- temp_df[duplicated(temp_df), ]
if (nrow(duplicated_rows) > 0) {
print("Se encontraron combinaciones de ID y TIME duplicadas:")
print(duplicated_rows)
# Opcional: Eliminar duplicados o consolidarlos según sea necesario
temp_df <- temp_df[!duplicated(temp_df), ]
# Crear matrices de inputs y outputs sin duplicados
input_matrix <- input_matrix[!duplicated(temp_df), ]
output_matrix <- output_matrix[!duplicated(temp_df), ]
} else {
print("No hay duplicados.")
# Convertir listas a matrices para el análisis sin duplicados
input_matrix <- do.call(rbind, input_data)
output_matrix <- do.call(rbind, output_data)
}
# Realizar el análisis Malmquist
library(Benchmarking)
malmquist_index <- malmquist(X = input_matrix, Y = output_matrix, ID = ID, TIME = TIME,
RTS = "vrs", ORIENTATION = "in")
# Ver los resultados
print(malmquist_index)
View(malmquist_index)
malmquist_index[["time"]]
malmquist_index[["e11"]]
# Crear un dataframe de eficiencia ordenado por ID y TIME
efficiency_df <- data.frame(
ID = malmquist_index$ID,
TIME = malmquist_index$TIME,
Efficiency = malmquist_index$Efficiency
)
# Ordenar el dataframe por ID y TIME
efficiency_df <- efficiency_df[order(efficiency_df$ID, efficiency_df$TIME), ]
str(malmquist_index)
# Extraer los valores si están correctamente disponibles
if (!is.null(malmquist_index$ID) && !is.null(malmquist_index$TIME) && !is.null(malmquist_index$Efficiency)) {
efficiency_df <- data.frame(
ID = as.vector(malmquist_index$ID),
TIME = as.vector(malmquist_index$TIME),
Efficiency = as.vector(malmquist_index$Efficiency)
)
# Ordenar el dataframe por ID y TIME
efficiency_df <- efficiency_df[order(efficiency_df$ID, efficiency_df$TIME), ]
# Mostrar el dataframe
print(efficiency_df)
} else {
print("Los datos de ID, TIME o Efficiency no están disponibles en malmquist_index.")
}
View(malmquist_index)
# Crear un dataframe de eficiencia ordenado por ID y TIME
efficiency_df <- data.frame(
ID = malmquist_index$id,
TIME = malmquist_index$time,
Efficiency = malmquist_index$e11
)
# Ordenar el dataframe por ID y TIME
efficiency_df <- efficiency_df[order(efficiency_df$ID, efficiency_df$TIME), ]
# Mostrar el dataframe
print(efficiency_df)
View(efficiency_df)
efficiency_df <- data.frame(
ID = malmquist_index$id,
TIME = malmquist_index$time,
Efficiency = malmquist_index$e11
)
# Ordenar el dataframe por ID y TIME
efficiency_df <- efficiency_df[order(efficiency_df$ID, efficiency_df$TIME), ]
# Transformar el dataframe en formato ancho (wide) con 'ID' como fila y 'TIME' como columnas
library(tidyr)
efficiency_wide <- pivot_wider(efficiency_df, names_from = TIME, values_from = Efficiency)
# Renombrar las columnas de año para mayor claridad (opcional)
colnames(efficiency_wide)[-1] <- paste0("Year_", colnames(efficiency_wide)[-1])
# Mostrar el dataframe en formato ancho
print(efficiency_wide)
View(efficiency_wide)
# Renombrar las columnas de año para mayor claridad (opcional)
colnames(efficiency_wide)[-1] <- paste0(colnames(efficiency_wide)[-1])
View(efficiency_wide)
# Crear el dataframe inicial
efficiency_df <- data.frame(
ID = malmquist_index$id,
TIME = malmquist_index$time,
Efficiency = malmquist_index$e11
)
# Ordenar el dataframe por ID y TIME
efficiency_df <- efficiency_df[order(efficiency_df$ID, efficiency_df$TIME), ]
# Transformar el dataframe en formato ancho (wide) con 'ID' como fila y 'TIME' como columnas
library(tidyr)
efficiency_wide <- pivot_wider(efficiency_df, names_from = TIME, values_from = Efficiency)
# Mostrar el dataframe en formato ancho sin prefijo de año
print(efficiency_wide)
View(efficiency_wide)
library(ggplot2)
# Convertir el dataframe a formato largo para graficar
efficiency_long <- pivot_longer(efficiency_wide, cols = -ID, names_to = "Year", values_to = "Efficiency")
# Convertir la columna Year a numérica para el eje x
efficiency_long$Year <- as.numeric(efficiency_long$Year)
# Crear el gráfico de líneas
ggplot(efficiency_long, aes(x = Year, y = Efficiency, group = ID, color = factor(ID))) +
geom_line(size = 1) +
geom_point() +
labs(
title = "Evolución de la Eficiencia Técnica de cada DMU (2014-2020)",
x = "Año",
y = "Eficiencia",
color = "ID del DMU"
) +
theme_minimal() +
theme(legend.position = "bottom")
